// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package oapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	JWTAuthScopes = "JWTAuth.Scopes"
)

// Defines values for HealthCheckParamsType.
const (
	Liveness  HealthCheckParamsType = "liveness"
	Readiness HealthCheckParamsType = "readiness"
)

// BadRequestRes defines model for BadRequestRes.
type BadRequestRes struct {
	Msg *string `json:"msg"`
}

// CollectionHistoryResponse defines model for CollectionHistoryResponse.
type CollectionHistoryResponse struct {
	Count       *uint               `json:"count,omitempty"`
	List        *[]CollectionRecord `json:"list,omitempty"`
	PageCurrent *int64              `json:"page_current,omitempty"`
	PageMax     *int64              `json:"page_max,omitempty"`
}

// CollectionRecord defines model for CollectionRecord.
type CollectionRecord struct {
	Amount *float32 `json:"amount,omitempty"`

	// BlockTimestamp Date of the record's block timestamp, in milliseconds.
	BlockTimestamp *int64  `json:"block_timestamp,omitempty"`
	Index          *int    `json:"index,omitempty"`
	TxHash         *string `json:"tx_hash,omitempty"`
}

// ConsumptionLogByKey defines model for ConsumptionLogByKey.
type ConsumptionLogByKey struct {
	// ApiCalls Total number of API calls made
	ApiCalls *int64 `json:"api_calls,omitempty"`

	// ConsumptionDate Date of which the consumption is calculated for. timestamp in milliseconds.
	ConsumptionDate *int64 `json:"consumption_date,omitempty"`

	// KeyName Key Name
	KeyName *string `json:"key_name,omitempty"`

	// RuUsed Total RU used
	RuUsed *int64 `json:"ru_used,omitempty"`
}

// ConsumptionLogResponse defines model for ConsumptionLogResponse.
type ConsumptionLogResponse struct {
	History *[]ConsumptionLogByKey `json:"history,omitempty"`

	// Since Date of which the consumption period starts. timestamp in milliseconds.
	Since *int64 `json:"since,omitempty"`

	// Until Date of which the consumption period ends. timestamp in milliseconds.
	Until *int64 `json:"until,omitempty"`
}

// DepositHistoryResponse defines model for DepositHistoryResponse.
type DepositHistoryResponse struct {
	Count       *uint            `json:"count,omitempty"`
	List        *[]DepositRecord `json:"list,omitempty"`
	PageCurrent *int64           `json:"page_current,omitempty"`
	PageMax     *int64           `json:"page_max,omitempty"`
}

// DepositRecord defines model for DepositRecord.
type DepositRecord struct {
	Amount *float32 `json:"amount,omitempty"`

	// BlockTimestamp Date of the record's block timestamp, in milliseconds.
	BlockTimestamp *int64  `json:"block_timestamp,omitempty"`
	Index          *int    `json:"index,omitempty"`
	TxHash         *string `json:"tx_hash,omitempty"`
}

// GetRequestWithdrawResponse defines model for GetRequestWithdrawResponse.
type GetRequestWithdrawResponse struct {
	Amount *float32 `json:"amount,omitempty"`
}

// Key defines model for Key.
type Key struct {
	// ApiCallsCurrent API calls count during this round
	ApiCallsCurrent *int64 `json:"api_calls_current,omitempty"`

	// ApiCallsTotal API calls count since this key's creation
	ApiCallsTotal *int64  `json:"api_calls_total,omitempty"`
	Id            *string `json:"id,omitempty"`
	Key           *string `json:"key,omitempty"`
	Name          *string `json:"name,omitempty"`

	// RuUsedCurrent RU used during this round
	RuUsedCurrent *int64 `json:"ru_used_current,omitempty"`

	// RuUsedTotal RU used since this key's creation
	RuUsedTotal *int64 `json:"ru_used_total,omitempty"`
}

// KeyInfoBody defines model for KeyInfoBody.
type KeyInfoBody struct {
	Name *string `json:"name,omitempty"`
}

// Keys defines model for Keys.
type Keys = []Key

// RUStatus defines model for RUStatus.
type RUStatus struct {
	// ApiCallsCurrent API calls count during this round
	ApiCallsCurrent *int64 `json:"api_calls_current,omitempty"`

	// ApiCallsTotal API calls count since this key's creation
	ApiCallsTotal *int64 `json:"api_calls_total,omitempty"`

	// RuLimit Current RU limit
	RuLimit *int64 `json:"ru_limit,omitempty"`

	// RuUsedCurrent RU used during this round
	RuUsedCurrent *int64 `json:"ru_used_current,omitempty"`

	// RuUsedTotal RU used since this key's creation
	RuUsedTotal *int64 `json:"ru_used_total,omitempty"`
}

// SIWESessionResponse defines model for SIWESessionResponse.
type SIWESessionResponse struct {
	Address *string `json:"address,omitempty"`
	ChainId *int    `json:"chainId,omitempty"`
}

// SIWEVerifyBody defines model for SIWEVerifyBody.
type SIWEVerifyBody struct {
	Message   *string `json:"message"`
	Signature *string `json:"signature"`
}

// UsersGetNonceResult defines model for UsersGetNonceResult.
type UsersGetNonceResult struct {
	Nonce *string `json:"nonce"`
}

// WithdrawalHistoryResponse defines model for WithdrawalHistoryResponse.
type WithdrawalHistoryResponse struct {
	Count       *uint               `json:"count,omitempty"`
	List        *[]WithdrawalRecord `json:"list,omitempty"`
	PageCurrent *int64              `json:"page_current,omitempty"`
	PageMax     *int64              `json:"page_max,omitempty"`
}

// WithdrawalRecord defines model for WithdrawalRecord.
type WithdrawalRecord struct {
	Amount *float32 `json:"amount,omitempty"`

	// BlockTimestamp Date of the record's block timestamp, in milliseconds.
	BlockTimestamp *int64   `json:"block_timestamp,omitempty"`
	Fee            *float32 `json:"fee,omitempty"`
	Index          *int     `json:"index,omitempty"`
	TxHash         *string  `json:"tx_hash,omitempty"`

	// User Token been withdrew to which address
	User *string `json:"user,omitempty"`
}

// Amount defines model for amount.
type Amount = float32

// KeyID defines model for keyID.
type KeyID = string

// Limit defines model for limit.
type Limit = uint

// Merge defines model for merge.
type Merge = bool

// Page defines model for page.
type Page = int64

// Since defines model for since.
type Since = int64

// Until defines model for until.
type Until = int64

// HealthCheckParams defines parameters for HealthCheck.
type HealthCheckParams struct {
	Type *HealthCheckParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// HealthCheckParamsType defines parameters for HealthCheck.
type HealthCheckParamsType string

// GetCollectionHistoryParams defines parameters for GetCollectionHistory.
type GetCollectionHistoryParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetConsumptionHistoryByAccountParams defines parameters for GetConsumptionHistoryByAccount.
type GetConsumptionHistoryByAccountParams struct {
	// Since Since timestamp (milliseconds)
	Since *Since `form:"since,omitempty" json:"since,omitempty"`

	// Until Until timestamp (milliseconds)
	Until *Until `form:"until,omitempty" json:"until,omitempty"`

	// Merge Whether to merge collection stats
	Merge *Merge `form:"merge,omitempty" json:"merge,omitempty"`
}

// GetConsumptionHistoryByKeyParams defines parameters for GetConsumptionHistoryByKey.
type GetConsumptionHistoryByKeyParams struct {
	// Since Since timestamp (milliseconds)
	Since *Since `form:"since,omitempty" json:"since,omitempty"`

	// Until Until timestamp (milliseconds)
	Until *Until `form:"until,omitempty" json:"until,omitempty"`

	// Merge Whether to merge collection stats
	Merge *Merge `form:"merge,omitempty" json:"merge,omitempty"`
}

// GetDepositHistoryParams defines parameters for GetDepositHistory.
type GetDepositHistoryParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetWithdrawalHistoryParams defines parameters for GetWithdrawalHistory.
type GetWithdrawalHistoryParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetPendingRequestWithdrawParams defines parameters for SetPendingRequestWithdraw.
type SetPendingRequestWithdrawParams struct {
	// Amount Amount of tokens
	Amount Amount `form:"amount" json:"amount"`
}

// GenerateKeyJSONRequestBody defines body for GenerateKey for application/json ContentType.
type GenerateKeyJSONRequestBody = KeyInfoBody

// UpdateKeyInfoJSONRequestBody defines body for UpdateKeyInfo for application/json ContentType.
type UpdateKeyInfoJSONRequestBody = KeyInfoBody

// SIWEVerifyJSONRequestBody defines body for SIWEVerify for application/json ContentType.
type SIWEVerifyJSONRequestBody = SIWEVerifyBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HealthCheck request
	HealthCheck(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionHistory request
	GetCollectionHistory(ctx context.Context, params *GetCollectionHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsumptionHistoryByAccount request
	GetConsumptionHistoryByAccount(ctx context.Context, params *GetConsumptionHistoryByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsumptionHistoryByKey request
	GetConsumptionHistoryByKey(ctx context.Context, keyID KeyID, params *GetConsumptionHistoryByKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDepositHistory request
	GetDepositHistory(ctx context.Context, params *GetDepositHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWithdrawalHistory request
	GetWithdrawalHistory(ctx context.Context, params *GetWithdrawalHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateKeyWithBody request with any body
	GenerateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateKey(ctx context.Context, body GenerateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKey request
	DeleteKey(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKey request
	GetKey(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RotateKey request
	RotateKey(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeyInfoWithBody request with any body
	UpdateKeyInfoWithBody(ctx context.Context, keyID KeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeyInfo(ctx context.Context, keyID KeyID, body UpdateKeyInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeys request
	GetKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingRequestWithdraw request
	GetPendingRequestWithdraw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPendingRequestWithdraw request
	SetPendingRequestWithdraw(ctx context.Context, params *SetPendingRequestWithdrawParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRUStatus request
	GetRUStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SIWELogout request
	SIWELogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SIWEGetNonce request
	SIWEGetNonce(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SIWEGetSession request
	SIWEGetSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SIWEVerifyWithBody request with any body
	SIWEVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SIWEVerify(ctx context.Context, body SIWEVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HealthCheck(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionHistory(ctx context.Context, params *GetCollectionHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsumptionHistoryByAccount(ctx context.Context, params *GetConsumptionHistoryByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsumptionHistoryByAccountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsumptionHistoryByKey(ctx context.Context, keyID KeyID, params *GetConsumptionHistoryByKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsumptionHistoryByKeyRequest(c.Server, keyID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDepositHistory(ctx context.Context, params *GetDepositHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepositHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWithdrawalHistory(ctx context.Context, params *GetWithdrawalHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWithdrawalHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateKey(ctx context.Context, body GenerateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKey(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeyRequest(c.Server, keyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKey(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyRequest(c.Server, keyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RotateKey(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRotateKeyRequest(c.Server, keyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeyInfoWithBody(ctx context.Context, keyID KeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeyInfoRequestWithBody(c.Server, keyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeyInfo(ctx context.Context, keyID KeyID, body UpdateKeyInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeyInfoRequest(c.Server, keyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingRequestWithdraw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingRequestWithdrawRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPendingRequestWithdraw(ctx context.Context, params *SetPendingRequestWithdrawParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPendingRequestWithdrawRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRUStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRUStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWELogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWELogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWEGetNonce(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWEGetNonceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWEGetSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWEGetSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWEVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWEVerifyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWEVerify(ctx context.Context, body SIWEVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWEVerifyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string, params *HealthCheckParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionHistoryRequest generates requests for GetCollectionHistory
func NewGetCollectionHistoryRequest(server string, params *GetCollectionHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/collection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsumptionHistoryByAccountRequest generates requests for GetConsumptionHistoryByAccount
func NewGetConsumptionHistoryByAccountRequest(server string, params *GetConsumptionHistoryByAccountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/consumption")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Merge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merge", runtime.ParamLocationQuery, *params.Merge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsumptionHistoryByKeyRequest generates requests for GetConsumptionHistoryByKey
func NewGetConsumptionHistoryByKeyRequest(server string, keyID KeyID, params *GetConsumptionHistoryByKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyID", runtime.ParamLocationPath, keyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/consumption/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Merge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merge", runtime.ParamLocationQuery, *params.Merge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDepositHistoryRequest generates requests for GetDepositHistory
func NewGetDepositHistoryRequest(server string, params *GetDepositHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/deposit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWithdrawalHistoryRequest generates requests for GetWithdrawalHistory
func NewGetWithdrawalHistoryRequest(server string, params *GetWithdrawalHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/withdrawal")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateKeyRequest calls the generic GenerateKey builder with application/json body
func NewGenerateKeyRequest(server string, body GenerateKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateKeyRequestWithBody generates requests for GenerateKey with any type of body
func NewGenerateKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeyRequest generates requests for DeleteKey
func NewDeleteKeyRequest(server string, keyID KeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyID", runtime.ParamLocationPath, keyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeyRequest generates requests for GetKey
func NewGetKeyRequest(server string, keyID KeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyID", runtime.ParamLocationPath, keyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRotateKeyRequest generates requests for RotateKey
func NewRotateKeyRequest(server string, keyID KeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyID", runtime.ParamLocationPath, keyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeyInfoRequest calls the generic UpdateKeyInfo builder with application/json body
func NewUpdateKeyInfoRequest(server string, keyID KeyID, body UpdateKeyInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeyInfoRequestWithBody(server, keyID, "application/json", bodyReader)
}

// NewUpdateKeyInfoRequestWithBody generates requests for UpdateKeyInfo with any type of body
func NewUpdateKeyInfoRequestWithBody(server string, keyID KeyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keyID", runtime.ParamLocationPath, keyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeysRequest generates requests for GetKeys
func NewGetKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingRequestWithdrawRequest generates requests for GetPendingRequestWithdraw
func NewGetPendingRequestWithdrawRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request/withdraw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPendingRequestWithdrawRequest generates requests for SetPendingRequestWithdraw
func NewSetPendingRequestWithdrawRequest(server string, params *SetPendingRequestWithdrawParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request/withdraw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRUStatusRequest generates requests for GetRUStatus
func NewGetRUStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ru/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSIWELogoutRequest generates requests for SIWELogout
func NewSIWELogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/siwe/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSIWEGetNonceRequest generates requests for SIWEGetNonce
func NewSIWEGetNonceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/siwe/nonce")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSIWEGetSessionRequest generates requests for SIWEGetSession
func NewSIWEGetSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/siwe/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSIWEVerifyRequest calls the generic SIWEVerify builder with application/json body
func NewSIWEVerifyRequest(server string, body SIWEVerifyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSIWEVerifyRequestWithBody(server, "application/json", bodyReader)
}

// NewSIWEVerifyRequestWithBody generates requests for SIWEVerify with any type of body
func NewSIWEVerifyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/siwe/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// GetCollectionHistoryWithResponse request
	GetCollectionHistoryWithResponse(ctx context.Context, params *GetCollectionHistoryParams, reqEditors ...RequestEditorFn) (*GetCollectionHistoryResponse, error)

	// GetConsumptionHistoryByAccountWithResponse request
	GetConsumptionHistoryByAccountWithResponse(ctx context.Context, params *GetConsumptionHistoryByAccountParams, reqEditors ...RequestEditorFn) (*GetConsumptionHistoryByAccountResponse, error)

	// GetConsumptionHistoryByKeyWithResponse request
	GetConsumptionHistoryByKeyWithResponse(ctx context.Context, keyID KeyID, params *GetConsumptionHistoryByKeyParams, reqEditors ...RequestEditorFn) (*GetConsumptionHistoryByKeyResponse, error)

	// GetDepositHistoryWithResponse request
	GetDepositHistoryWithResponse(ctx context.Context, params *GetDepositHistoryParams, reqEditors ...RequestEditorFn) (*GetDepositHistoryResponse, error)

	// GetWithdrawalHistoryWithResponse request
	GetWithdrawalHistoryWithResponse(ctx context.Context, params *GetWithdrawalHistoryParams, reqEditors ...RequestEditorFn) (*GetWithdrawalHistoryResponse, error)

	// GenerateKeyWithBodyWithResponse request with any body
	GenerateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error)

	GenerateKeyWithResponse(ctx context.Context, body GenerateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error)

	// DeleteKeyWithResponse request
	DeleteKeyWithResponse(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error)

	// GetKeyWithResponse request
	GetKeyWithResponse(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*GetKeyResponse, error)

	// RotateKeyWithResponse request
	RotateKeyWithResponse(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*RotateKeyResponse, error)

	// UpdateKeyInfoWithBodyWithResponse request with any body
	UpdateKeyInfoWithBodyWithResponse(ctx context.Context, keyID KeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeyInfoResponse, error)

	UpdateKeyInfoWithResponse(ctx context.Context, keyID KeyID, body UpdateKeyInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeyInfoResponse, error)

	// GetKeysWithResponse request
	GetKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeysResponse, error)

	// GetPendingRequestWithdrawWithResponse request
	GetPendingRequestWithdrawWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingRequestWithdrawResponse, error)

	// SetPendingRequestWithdrawWithResponse request
	SetPendingRequestWithdrawWithResponse(ctx context.Context, params *SetPendingRequestWithdrawParams, reqEditors ...RequestEditorFn) (*SetPendingRequestWithdrawResponse, error)

	// GetRUStatusWithResponse request
	GetRUStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRUStatusResponse, error)

	// SIWELogoutWithResponse request
	SIWELogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWELogoutResponse, error)

	// SIWEGetNonceWithResponse request
	SIWEGetNonceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWEGetNonceResponse, error)

	// SIWEGetSessionWithResponse request
	SIWEGetSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWEGetSessionResponse, error)

	// SIWEVerifyWithBodyWithResponse request with any body
	SIWEVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SIWEVerifyResponse, error)

	SIWEVerifyWithResponse(ctx context.Context, body SIWEVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*SIWEVerifyResponse, error)
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionHistoryResponse
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetCollectionHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsumptionHistoryByAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsumptionLogResponse
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetConsumptionHistoryByAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsumptionHistoryByAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsumptionHistoryByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsumptionLogResponse
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetConsumptionHistoryByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsumptionHistoryByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDepositHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DepositHistoryResponse
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetDepositHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepositHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWithdrawalHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WithdrawalHistoryResponse
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetWithdrawalHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWithdrawalHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GenerateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r DeleteKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RotateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON401      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r RotateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RotateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeyInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON401      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r UpdateKeyInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeyInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Keys
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingRequestWithdrawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRequestWithdrawResponse
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetPendingRequestWithdrawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingRequestWithdrawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPendingRequestWithdrawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r SetPendingRequestWithdrawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPendingRequestWithdrawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRUStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RUStatus
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetRUStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRUStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SIWELogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SIWELogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SIWELogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SIWEGetNonceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r SIWEGetNonceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SIWEGetNonceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SIWEGetSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SIWESessionResponse
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r SIWEGetSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SIWEGetSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SIWEVerifyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r SIWEVerifyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SIWEVerifyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// GetCollectionHistoryWithResponse request returning *GetCollectionHistoryResponse
func (c *ClientWithResponses) GetCollectionHistoryWithResponse(ctx context.Context, params *GetCollectionHistoryParams, reqEditors ...RequestEditorFn) (*GetCollectionHistoryResponse, error) {
	rsp, err := c.GetCollectionHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionHistoryResponse(rsp)
}

// GetConsumptionHistoryByAccountWithResponse request returning *GetConsumptionHistoryByAccountResponse
func (c *ClientWithResponses) GetConsumptionHistoryByAccountWithResponse(ctx context.Context, params *GetConsumptionHistoryByAccountParams, reqEditors ...RequestEditorFn) (*GetConsumptionHistoryByAccountResponse, error) {
	rsp, err := c.GetConsumptionHistoryByAccount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsumptionHistoryByAccountResponse(rsp)
}

// GetConsumptionHistoryByKeyWithResponse request returning *GetConsumptionHistoryByKeyResponse
func (c *ClientWithResponses) GetConsumptionHistoryByKeyWithResponse(ctx context.Context, keyID KeyID, params *GetConsumptionHistoryByKeyParams, reqEditors ...RequestEditorFn) (*GetConsumptionHistoryByKeyResponse, error) {
	rsp, err := c.GetConsumptionHistoryByKey(ctx, keyID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsumptionHistoryByKeyResponse(rsp)
}

// GetDepositHistoryWithResponse request returning *GetDepositHistoryResponse
func (c *ClientWithResponses) GetDepositHistoryWithResponse(ctx context.Context, params *GetDepositHistoryParams, reqEditors ...RequestEditorFn) (*GetDepositHistoryResponse, error) {
	rsp, err := c.GetDepositHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepositHistoryResponse(rsp)
}

// GetWithdrawalHistoryWithResponse request returning *GetWithdrawalHistoryResponse
func (c *ClientWithResponses) GetWithdrawalHistoryWithResponse(ctx context.Context, params *GetWithdrawalHistoryParams, reqEditors ...RequestEditorFn) (*GetWithdrawalHistoryResponse, error) {
	rsp, err := c.GetWithdrawalHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWithdrawalHistoryResponse(rsp)
}

// GenerateKeyWithBodyWithResponse request with arbitrary body returning *GenerateKeyResponse
func (c *ClientWithResponses) GenerateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error) {
	rsp, err := c.GenerateKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateKeyResponse(rsp)
}

func (c *ClientWithResponses) GenerateKeyWithResponse(ctx context.Context, body GenerateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error) {
	rsp, err := c.GenerateKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateKeyResponse(rsp)
}

// DeleteKeyWithResponse request returning *DeleteKeyResponse
func (c *ClientWithResponses) DeleteKeyWithResponse(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error) {
	rsp, err := c.DeleteKey(ctx, keyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeyResponse(rsp)
}

// GetKeyWithResponse request returning *GetKeyResponse
func (c *ClientWithResponses) GetKeyWithResponse(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*GetKeyResponse, error) {
	rsp, err := c.GetKey(ctx, keyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeyResponse(rsp)
}

// RotateKeyWithResponse request returning *RotateKeyResponse
func (c *ClientWithResponses) RotateKeyWithResponse(ctx context.Context, keyID KeyID, reqEditors ...RequestEditorFn) (*RotateKeyResponse, error) {
	rsp, err := c.RotateKey(ctx, keyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRotateKeyResponse(rsp)
}

// UpdateKeyInfoWithBodyWithResponse request with arbitrary body returning *UpdateKeyInfoResponse
func (c *ClientWithResponses) UpdateKeyInfoWithBodyWithResponse(ctx context.Context, keyID KeyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeyInfoResponse, error) {
	rsp, err := c.UpdateKeyInfoWithBody(ctx, keyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeyInfoResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeyInfoWithResponse(ctx context.Context, keyID KeyID, body UpdateKeyInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeyInfoResponse, error) {
	rsp, err := c.UpdateKeyInfo(ctx, keyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeyInfoResponse(rsp)
}

// GetKeysWithResponse request returning *GetKeysResponse
func (c *ClientWithResponses) GetKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeysResponse, error) {
	rsp, err := c.GetKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeysResponse(rsp)
}

// GetPendingRequestWithdrawWithResponse request returning *GetPendingRequestWithdrawResponse
func (c *ClientWithResponses) GetPendingRequestWithdrawWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingRequestWithdrawResponse, error) {
	rsp, err := c.GetPendingRequestWithdraw(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingRequestWithdrawResponse(rsp)
}

// SetPendingRequestWithdrawWithResponse request returning *SetPendingRequestWithdrawResponse
func (c *ClientWithResponses) SetPendingRequestWithdrawWithResponse(ctx context.Context, params *SetPendingRequestWithdrawParams, reqEditors ...RequestEditorFn) (*SetPendingRequestWithdrawResponse, error) {
	rsp, err := c.SetPendingRequestWithdraw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPendingRequestWithdrawResponse(rsp)
}

// GetRUStatusWithResponse request returning *GetRUStatusResponse
func (c *ClientWithResponses) GetRUStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRUStatusResponse, error) {
	rsp, err := c.GetRUStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRUStatusResponse(rsp)
}

// SIWELogoutWithResponse request returning *SIWELogoutResponse
func (c *ClientWithResponses) SIWELogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWELogoutResponse, error) {
	rsp, err := c.SIWELogout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWELogoutResponse(rsp)
}

// SIWEGetNonceWithResponse request returning *SIWEGetNonceResponse
func (c *ClientWithResponses) SIWEGetNonceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWEGetNonceResponse, error) {
	rsp, err := c.SIWEGetNonce(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWEGetNonceResponse(rsp)
}

// SIWEGetSessionWithResponse request returning *SIWEGetSessionResponse
func (c *ClientWithResponses) SIWEGetSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWEGetSessionResponse, error) {
	rsp, err := c.SIWEGetSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWEGetSessionResponse(rsp)
}

// SIWEVerifyWithBodyWithResponse request with arbitrary body returning *SIWEVerifyResponse
func (c *ClientWithResponses) SIWEVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SIWEVerifyResponse, error) {
	rsp, err := c.SIWEVerifyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWEVerifyResponse(rsp)
}

func (c *ClientWithResponses) SIWEVerifyWithResponse(ctx context.Context, body SIWEVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*SIWEVerifyResponse, error) {
	rsp, err := c.SIWEVerify(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWEVerifyResponse(rsp)
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCollectionHistoryResponse parses an HTTP response from a GetCollectionHistoryWithResponse call
func ParseGetCollectionHistoryResponse(rsp *http.Response) (*GetCollectionHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionHistoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConsumptionHistoryByAccountResponse parses an HTTP response from a GetConsumptionHistoryByAccountWithResponse call
func ParseGetConsumptionHistoryByAccountResponse(rsp *http.Response) (*GetConsumptionHistoryByAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsumptionHistoryByAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsumptionLogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetConsumptionHistoryByKeyResponse parses an HTTP response from a GetConsumptionHistoryByKeyWithResponse call
func ParseGetConsumptionHistoryByKeyResponse(rsp *http.Response) (*GetConsumptionHistoryByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsumptionHistoryByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsumptionLogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetDepositHistoryResponse parses an HTTP response from a GetDepositHistoryWithResponse call
func ParseGetDepositHistoryResponse(rsp *http.Response) (*GetDepositHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDepositHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DepositHistoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWithdrawalHistoryResponse parses an HTTP response from a GetWithdrawalHistoryWithResponse call
func ParseGetWithdrawalHistoryResponse(rsp *http.Response) (*GetWithdrawalHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWithdrawalHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WithdrawalHistoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateKeyResponse parses an HTTP response from a GenerateKeyWithResponse call
func ParseGenerateKeyResponse(rsp *http.Response) (*GenerateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteKeyResponse parses an HTTP response from a DeleteKeyWithResponse call
func ParseDeleteKeyResponse(rsp *http.Response) (*DeleteKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetKeyResponse parses an HTTP response from a GetKeyWithResponse call
func ParseGetKeyResponse(rsp *http.Response) (*GetKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRotateKeyResponse parses an HTTP response from a RotateKeyWithResponse call
func ParseRotateKeyResponse(rsp *http.Response) (*RotateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RotateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateKeyInfoResponse parses an HTTP response from a UpdateKeyInfoWithResponse call
func ParseUpdateKeyInfoResponse(rsp *http.Response) (*UpdateKeyInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeyInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetKeysResponse parses an HTTP response from a GetKeysWithResponse call
func ParseGetKeysResponse(rsp *http.Response) (*GetKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Keys
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPendingRequestWithdrawResponse parses an HTTP response from a GetPendingRequestWithdrawWithResponse call
func ParseGetPendingRequestWithdrawResponse(rsp *http.Response) (*GetPendingRequestWithdrawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingRequestWithdrawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRequestWithdrawResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetPendingRequestWithdrawResponse parses an HTTP response from a SetPendingRequestWithdrawWithResponse call
func ParseSetPendingRequestWithdrawResponse(rsp *http.Response) (*SetPendingRequestWithdrawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPendingRequestWithdrawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRUStatusResponse parses an HTTP response from a GetRUStatusWithResponse call
func ParseGetRUStatusResponse(rsp *http.Response) (*GetRUStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRUStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RUStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSIWELogoutResponse parses an HTTP response from a SIWELogoutWithResponse call
func ParseSIWELogoutResponse(rsp *http.Response) (*SIWELogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SIWELogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSIWEGetNonceResponse parses an HTTP response from a SIWEGetNonceWithResponse call
func ParseSIWEGetNonceResponse(rsp *http.Response) (*SIWEGetNonceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SIWEGetNonceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSIWEGetSessionResponse parses an HTTP response from a SIWEGetSessionWithResponse call
func ParseSIWEGetSessionResponse(rsp *http.Response) (*SIWEGetSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SIWEGetSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SIWESessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSIWEVerifyResponse parses an HTTP response from a SIWEVerifyWithResponse call
func ParseSIWEVerifyResponse(rsp *http.Response) (*SIWEVerifyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SIWEVerifyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// health check
	// (GET /health)
	HealthCheck(ctx echo.Context, params HealthCheckParams) error
	// Get collection history
	// (GET /history/collection)
	GetCollectionHistory(ctx echo.Context, params GetCollectionHistoryParams) error
	// Get consumption history of a specific account
	// (GET /history/consumption)
	GetConsumptionHistoryByAccount(ctx echo.Context, params GetConsumptionHistoryByAccountParams) error
	// Get consumption history of a specific key
	// (GET /history/consumption/{keyID})
	GetConsumptionHistoryByKey(ctx echo.Context, keyID KeyID, params GetConsumptionHistoryByKeyParams) error
	// Get deposit history
	// (GET /history/deposit)
	GetDepositHistory(ctx echo.Context, params GetDepositHistoryParams) error
	// Get withdrawal history
	// (GET /history/withdrawal)
	GetWithdrawalHistory(ctx echo.Context, params GetWithdrawalHistoryParams) error
	// Generate an API Key
	// (POST /key)
	GenerateKey(ctx echo.Context) error
	// Delete an API Key
	// (DELETE /key/{keyID})
	DeleteKey(ctx echo.Context, keyID KeyID) error
	// Get an API Key' info
	// (GET /key/{keyID})
	GetKey(ctx echo.Context, keyID KeyID) error
	// Reassign the API Key's secret
	// (PATCH /key/{keyID})
	RotateKey(ctx echo.Context, keyID KeyID) error
	// Update an API Key's info
	// (PUT /key/{keyID})
	UpdateKeyInfo(ctx echo.Context, keyID KeyID) error
	// List API Keys of current account
	// (GET /keys)
	GetKeys(ctx echo.Context) error
	// Get current withdraw request
	// (GET /request/withdraw)
	GetPendingRequestWithdraw(ctx echo.Context) error
	// Request withdraw tokens at the end of this epoch
	// (POST /request/withdraw)
	SetPendingRequestWithdraw(ctx echo.Context, params SetPendingRequestWithdrawParams) error
	// Get account usage
	// (GET /ru/status)
	GetRUStatus(ctx echo.Context) error
	// SIWE logout
	// (GET /users/siwe/logout)
	SIWELogout(ctx echo.Context) error
	// Get SIWE nonce
	// (GET /users/siwe/nonce)
	SIWEGetNonce(ctx echo.Context) error
	// Get SIWE session
	// (GET /users/siwe/session)
	SIWEGetSession(ctx echo.Context) error
	// Verify SIWE (login)
	// (POST /users/siwe/verify)
	SIWEVerify(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params HealthCheckParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx, params)
	return err
}

// GetCollectionHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectionHistory(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectionHistoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollectionHistory(ctx, params)
	return err
}

// GetConsumptionHistoryByAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetConsumptionHistoryByAccount(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsumptionHistoryByAccountParams
	// ------------- Optional query parameter "since" -------------

	err = runtime.BindQueryParameter("form", true, false, "since", ctx.QueryParams(), &params.Since)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since: %s", err))
	}

	// ------------- Optional query parameter "until" -------------

	err = runtime.BindQueryParameter("form", true, false, "until", ctx.QueryParams(), &params.Until)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until: %s", err))
	}

	// ------------- Optional query parameter "merge" -------------

	err = runtime.BindQueryParameter("form", true, false, "merge", ctx.QueryParams(), &params.Merge)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter merge: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConsumptionHistoryByAccount(ctx, params)
	return err
}

// GetConsumptionHistoryByKey converts echo context to params.
func (w *ServerInterfaceWrapper) GetConsumptionHistoryByKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "keyID" -------------
	var keyID KeyID

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", ctx.Param("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyID: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsumptionHistoryByKeyParams
	// ------------- Optional query parameter "since" -------------

	err = runtime.BindQueryParameter("form", true, false, "since", ctx.QueryParams(), &params.Since)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since: %s", err))
	}

	// ------------- Optional query parameter "until" -------------

	err = runtime.BindQueryParameter("form", true, false, "until", ctx.QueryParams(), &params.Until)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until: %s", err))
	}

	// ------------- Optional query parameter "merge" -------------

	err = runtime.BindQueryParameter("form", true, false, "merge", ctx.QueryParams(), &params.Merge)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter merge: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConsumptionHistoryByKey(ctx, keyID, params)
	return err
}

// GetDepositHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetDepositHistory(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDepositHistoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDepositHistory(ctx, params)
	return err
}

// GetWithdrawalHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetWithdrawalHistory(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWithdrawalHistoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWithdrawalHistory(ctx, params)
	return err
}

// GenerateKey converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateKey(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GenerateKey(ctx)
	return err
}

// DeleteKey converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "keyID" -------------
	var keyID KeyID

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", ctx.Param("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyID: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteKey(ctx, keyID)
	return err
}

// GetKey converts echo context to params.
func (w *ServerInterfaceWrapper) GetKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "keyID" -------------
	var keyID KeyID

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", ctx.Param("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyID: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetKey(ctx, keyID)
	return err
}

// RotateKey converts echo context to params.
func (w *ServerInterfaceWrapper) RotateKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "keyID" -------------
	var keyID KeyID

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", ctx.Param("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyID: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RotateKey(ctx, keyID)
	return err
}

// UpdateKeyInfo converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateKeyInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "keyID" -------------
	var keyID KeyID

	err = runtime.BindStyledParameterWithOptions("simple", "keyID", ctx.Param("keyID"), &keyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyID: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateKeyInfo(ctx, keyID)
	return err
}

// GetKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetKeys(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetKeys(ctx)
	return err
}

// GetPendingRequestWithdraw converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingRequestWithdraw(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPendingRequestWithdraw(ctx)
	return err
}

// SetPendingRequestWithdraw converts echo context to params.
func (w *ServerInterfaceWrapper) SetPendingRequestWithdraw(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetPendingRequestWithdrawParams
	// ------------- Required query parameter "amount" -------------

	err = runtime.BindQueryParameter("form", true, true, "amount", ctx.QueryParams(), &params.Amount)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter amount: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetPendingRequestWithdraw(ctx, params)
	return err
}

// GetRUStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetRUStatus(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRUStatus(ctx)
	return err
}

// SIWELogout converts echo context to params.
func (w *ServerInterfaceWrapper) SIWELogout(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SIWELogout(ctx)
	return err
}

// SIWEGetNonce converts echo context to params.
func (w *ServerInterfaceWrapper) SIWEGetNonce(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SIWEGetNonce(ctx)
	return err
}

// SIWEGetSession converts echo context to params.
func (w *ServerInterfaceWrapper) SIWEGetSession(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SIWEGetSession(ctx)
	return err
}

// SIWEVerify converts echo context to params.
func (w *ServerInterfaceWrapper) SIWEVerify(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SIWEVerify(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/health", wrapper.HealthCheck)
	router.GET(baseURL+"/history/collection", wrapper.GetCollectionHistory)
	router.GET(baseURL+"/history/consumption", wrapper.GetConsumptionHistoryByAccount)
	router.GET(baseURL+"/history/consumption/:keyID", wrapper.GetConsumptionHistoryByKey)
	router.GET(baseURL+"/history/deposit", wrapper.GetDepositHistory)
	router.GET(baseURL+"/history/withdrawal", wrapper.GetWithdrawalHistory)
	router.POST(baseURL+"/key", wrapper.GenerateKey)
	router.DELETE(baseURL+"/key/:keyID", wrapper.DeleteKey)
	router.GET(baseURL+"/key/:keyID", wrapper.GetKey)
	router.PATCH(baseURL+"/key/:keyID", wrapper.RotateKey)
	router.PUT(baseURL+"/key/:keyID", wrapper.UpdateKeyInfo)
	router.GET(baseURL+"/keys", wrapper.GetKeys)
	router.GET(baseURL+"/request/withdraw", wrapper.GetPendingRequestWithdraw)
	router.POST(baseURL+"/request/withdraw", wrapper.SetPendingRequestWithdraw)
	router.GET(baseURL+"/ru/status", wrapper.GetRUStatus)
	router.GET(baseURL+"/users/siwe/logout", wrapper.SIWELogout)
	router.GET(baseURL+"/users/siwe/nonce", wrapper.SIWEGetNonce)
	router.GET(baseURL+"/users/siwe/session", wrapper.SIWEGetSession)
	router.POST(baseURL+"/users/siwe/verify", wrapper.SIWEVerify)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xbb1PbuPN/Kxr/fjN3N+MSJyEkpHMP+HecaUuvAcq11w6j2OtYjS25ktwQOrz370hy",
	"4gTb+QOlXK+Z4QGxFe1q97MfrVabr5bH4oRRoFJY3a9WgjmOQQLXn3DMUirVfz4Ij5NEEkatrrWnnyMW",
	"IMmGQIVlW0Q9/5wCH1u2RXEMVnfyddvi8DklHHyrK3kKtiW8EGKs5g0Yj7G0ulYQMayGynGivkrTuA/c",
	"ur21rSGM3cOiDkMYT8QmWIa5VDN+kdBMhpCc0IGWEZGYlKzzpXqMZAjI6KNWTCTEAiXAUYIHULFyM9+s",
	"TB8CnEbS6tYdx86XnRI6s2pCJQyyZcfAB1BU6TIEGQJHkiE9AnksisBTb5GQWFb5wkxXqlGAIwFTHfqM",
	"RYCp1kGvsKDCeQh67ZlRKgRm1ilxNaFyZ7t80YJQr0TimXqMJIlBSBwn6NeYRBER4DHqi98qFDBzratB",
	"SiWJihpcqMframDmWk+D28lwHYD72O/B5xSE7IGJT84S4JKYT7EYFPFsW9fPWKxgmshx5l01bTaK9T+B",
	"J61b2zqYIudPIiTj4x6IhFEBRUHehAeWAVeFktAjdZyof/6fQ2B1rf+r5UxTy5ZYy1Xogce4b+V6Ys7x",
	"2MpAeOWlnMMdFapsmH0lxterOn2BaTK9ChbJqfEOY9lWP2Le8GqKlSKYDrEETZ4hIK7n/0Ug/a0cYTYi",
	"FM2CbMuyV1k6oT5cz6g180peX4VYhOUMWGICKtJYq/ySDfbHL2BcYoWEXHk4ikQJSzCJoxne3PvLRXoo",
	"irEPqy3Gy3W48rGEalOOQuKF2qAz30FEKJFeGmEJPgoY35oJ4fvZdwjjKxPed1V5AWN0qt7Yd81rWzy9",
	"SgX4VVbqXSD92r4vWmddVR3FoQnzNaKzCIGSAK0g7cWuSYAT5qsti0vxcLdU0PZKOoAS80ANytxyCAkT",
	"RD4ZuWby/13MOq/Uz0erxyCzHf2SyNDneFQNjNwYK6TJBUmLCXvW73eS+ylRa2AiP1WrQTIkAnGWUn81",
	"i+WSpOK45XKESfKUmCGMfxHI44D12NU85Jd4QPN16fMJh1dRdbV9MrK+r10m81dYZTL7g6xRAQeXBmyf",
	"+SWwqLBGxTxiZQqq2DF6F2cSy1T8TPjk6VXFKfPArFRlAZNz4xo4+q/h9My9PDoDIXTuXcmMvs9BiKWH",
	"H3XyV3lkiAl1/RL+Lhtf0Kr0RGU0fQucBOPyoIpBiOwADdc4TiJdGWAejkImZLfpOA4aYSoFGrNUHegF",
	"GVC1P42IDNUzjo7UWR/SGGFPg7D7gTrXh82jjgfbne06+DutzpHX8b3+7u5+G7e3+/DHQbPdbrSaR3sf",
	"6Jma0KVIbTX5XJKhhLMvoMV6jErOIuPBEY4ikFsf6EXP7aJQyqRbq81r/IG+Ba6c00X1D/RAGRa5h/rD",
	"KaMedNHNQef4dfvwuBG+fdn7DPsfqCtECj7ak13UcBrNZ3XnWb1+7rS7jUa3ubPlONvvC0lzhc2VibBM",
	"+R2rOtetprPrOZ16e2e73+z7zd1GAwftoO51HKeBd/pBAO02bgJg6ECr7Xe2cXM7cKDdbLX6rVbd2Wn4",
	"rZ1OO4CW3663d9q7Dew54Ncdv+O0mtv1Pu74QavRbHles95s+9hr+v0+4Hqj3WlDUO+vtoRVwXUhgItj",
	"kNqoPRC6UlOgbZZl3vesAExSEBw9WZKaq/DvylMLev0wqWoAUKrUvVJY20oF8LJz6xAo6gMYtvI5jBSv",
	"mHPWhJ3t5fmECmnwUk7k+Ewhwpj25PJ8L5VaH11X8xgbEpgpLKcyvNKl51wGTojONm71UgOmF0NklL17",
	"NsASRnhs2dYXQ2BW16pvOVuOWiRLgOKEWF2rueVs1S1b15S1LrUQcGR0GYB2twKB3uLUjmL9qV8fhOAN",
	"9dfy+vk/X0urglrf2aIg0DS2uv9YEfkC1NiNA/aJ/v9j0Ygf1XsTp1rDhuOUlExTz1Pfv7WtbfNeMX0W",
	"QDhJIuLpNdQ+CTX+64w+i8J1viCpjT0vdx/7KBthZG9/P9kpHVI2oshTzkDabBpgaRxjPra6lnGlea+Q",
	"gwfKTdlj66MaXMuKJLW8rl7p+mOQhRpqEQNlS8qH1HSd/NZeOs6khlXO/yYGri4Ilxh7DmD17+fkC6qi",
	"n3FyA3qzaH1PdLtUAqc4OgP+BfgR54zPcZh2+JS9/vmo3JXD7xjk7HVNOEXMFIjZk7tInJasFkNxOixz",
	"3/54z6SNa4PSlPRWQKWpu60w0Nw/PTJ8S8ugy7D7lOT4ZHGzJmbzmmkGSpW8YCQS8EhAvMnxpATKc0X8",
	"amDXvupr29t1Af4C1mdcc0G8AmY3UbCJgnWiwLQkFCPAPK+OA9/UxBdhf/4u4UdOMipuRTYZxrfKMDI0",
	"rZxejKYn3UUALJQKfmQMVtc9NjD8VjDMYbUUidkdTcJEKfao+ghmp+dG60nB9ZsYY/ZmRJtivnPs9hGB",
	"OK1YbHbme+/MBh4IU91i8mJuD1bImmJsNsf0IQLTTzKPtkP9/AFZ5frFmSeklO9anZkD18r+NQ5Z5F27",
	"cs/69m7cBP1/CJCnTKJAX4iut7PlWPwF6UpzEZEJll5YxGSPSfwY7PLdYLnhqkXg6AEW+g5XhjCFiEAC",
	"PA6yDCVpCW9dJL7BiGugdX+c/HSZ0gadi9BpgDXLXqKcvrJ0SSw6DuouoMd1t9hskg/KjF8SISeuFogF",
	"KLtBLynW5n7PWGNaFFiEgb+A+oQO7rQzPiYqFjRPbg7uDy9wZviY+B5lYJgBSv5kChC9kZWe3M8WQGS9",
	"XS1rtfjBbr43kFuSLelJc7iZ3xIibH5xB9Q3HTJEIEiYFy6DoaavtCamnaVVvDXtPn1EpprK2OxhD0hZ",
	"9GnL7FYoFeYHhVMMpJnPU2Hu6kZQi9iApbP3KHcM714eoWyMfZes3Mujl5NXq5OMbYWA/eznsmcgnx2Y",
	"VqVik28EmKNpI9NM98+0iTHvavr9OfoLy/D32nP0p5TJaxqNnyO4TggH8ft5mNroBFPk1FF9t+0gx+nq",
	"P3RxfvC8pOnqdnWDz1toYmpt4aK1p92HpcZWvtPTmWFl9p60Ny4PRAnXspZEmNzB5LzIiaQZk/Y9H4JB",
	"SD4No5iypMw6C8LzSUruyNTc0UzRfS4g5oy6xEXCNFIvd9JkYIWbzqavH40xy/q+f1Tv5NZc4p8vun18",
	"9vJjXqppLzeT/hqxAaG/lbrIjHuk+5E7fe6rH/wfSJl7GV3qHnVMqPkVA6CTy3OTK6CAcaRYE6jMlrac",
	"WmF8EvaPPfKanLgXN279lLjCpb2Wd+DuuMPk77cHJ7tbMD658S9d8pq4168+vXJOz981Xx8ORy4ZkX78",
	"h3x/5u64US/ymm/Iy4OT5N3fb8jrT0f1V+fvxq9uhqNXn052tzovkj/qjTfB7u774fHNm3eOd/rFoSIK",
	"35O37853D/f3DrfPo9NRe7xX5PtSHv+JEgYNuGxuFGASPeEl6KKYL4/QQtjrHVhNYs47KY+srlWzbj/e",
	"/i8AAP//EoWVt4JDAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
