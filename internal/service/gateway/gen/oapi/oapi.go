// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package oapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	JWTAuthScopes = "JWTAuth.Scopes"
)

// Defines values for HealthCheckParamsType.
const (
	Liveness  HealthCheckParamsType = "liveness"
	Readiness HealthCheckParamsType = "readiness"
)

// BadRequestRes defines model for BadRequestRes.
type BadRequestRes struct {
	Msg *string `json:"msg"`
}

// CollectionHistoryResponse defines model for CollectionHistoryResponse.
type CollectionHistoryResponse struct {
	Count       *uint               `json:"count,omitempty"`
	List        *[]CollectionRecord `json:"list,omitempty"`
	PageCurrent *int64              `json:"page_current,omitempty"`
	PageMax     *int64              `json:"page_max,omitempty"`
}

// CollectionRecord defines model for CollectionRecord.
type CollectionRecord struct {
	Amount *float32 `json:"amount,omitempty"`

	// BlockTimestamp Date of the record's block timestamp, in milliseconds.
	BlockTimestamp *int64  `json:"block_timestamp,omitempty"`
	Index          *int    `json:"index,omitempty"`
	TxHash         *string `json:"tx_hash,omitempty"`
}

// ConsumptionLogByKey defines model for ConsumptionLogByKey.
type ConsumptionLogByKey struct {
	// ApiCalls Total number of API calls made
	ApiCalls *int64 `json:"api_calls,omitempty"`

	// ConsumptionDate Date of which the consumption is calculated for. timestamp in milliseconds.
	ConsumptionDate *int64 `json:"consumption_date,omitempty"`

	// KeyName Key Name
	KeyName *string `json:"key_name,omitempty"`

	// RuUsed Total RU used
	RuUsed *int64 `json:"ru_used,omitempty"`
}

// ConsumptionLogResponse defines model for ConsumptionLogResponse.
type ConsumptionLogResponse struct {
	History *[]ConsumptionLogByKey `json:"history,omitempty"`

	// Since Date of which the consumption period starts. timestamp in milliseconds.
	Since *int64 `json:"since,omitempty"`

	// Until Date of which the consumption period ends. timestamp in milliseconds.
	Until *int64 `json:"until,omitempty"`
}

// DepositHistoryResponse defines model for DepositHistoryResponse.
type DepositHistoryResponse struct {
	Count       *uint            `json:"count,omitempty"`
	List        *[]DepositRecord `json:"list,omitempty"`
	PageCurrent *int64           `json:"page_current,omitempty"`
	PageMax     *int64           `json:"page_max,omitempty"`
}

// DepositRecord defines model for DepositRecord.
type DepositRecord struct {
	Amount *float32 `json:"amount,omitempty"`

	// BlockTimestamp Date of the record's block timestamp, in milliseconds.
	BlockTimestamp *int64  `json:"block_timestamp,omitempty"`
	Index          *int    `json:"index,omitempty"`
	TxHash         *string `json:"tx_hash,omitempty"`
}

// GetRequestWithdrawResponse defines model for GetRequestWithdrawResponse.
type GetRequestWithdrawResponse struct {
	Amount *float32 `json:"amount,omitempty"`
}

// Key defines model for Key.
type Key struct {
	// ApiCallsCurrent API calls count during this round
	ApiCallsCurrent *int64 `json:"api_calls_current,omitempty"`

	// ApiCallsTotal API calls count since this key's creation
	ApiCallsTotal *int64  `json:"api_calls_total,omitempty"`
	Id            *int    `json:"id,omitempty"`
	Key           *string `json:"key,omitempty"`
	Name          *string `json:"name,omitempty"`

	// RuUsedCurrent RU used during this round
	RuUsedCurrent *int64 `json:"ru_used_current,omitempty"`

	// RuUsedTotal RU used since this key's creation
	RuUsedTotal *int64 `json:"ru_used_total,omitempty"`
}

// KeyInfoBody defines model for KeyInfoBody.
type KeyInfoBody struct {
	Name *string `json:"name,omitempty"`
}

// Keys defines model for Keys.
type Keys = []Key

// RUStatus defines model for RUStatus.
type RUStatus struct {
	// ApiCallsCurrent API calls count during this round
	ApiCallsCurrent *int64 `json:"api_calls_current,omitempty"`

	// ApiCallsTotal API calls count since this key's creation
	ApiCallsTotal *int64 `json:"api_calls_total,omitempty"`

	// RuLimit Current RU limit
	RuLimit *int64 `json:"ru_limit,omitempty"`

	// RuUsedCurrent RU used during this round
	RuUsedCurrent *int64 `json:"ru_used_current,omitempty"`

	// RuUsedTotal RU used since this key's creation
	RuUsedTotal *int64 `json:"ru_used_total,omitempty"`
}

// SIWESessionResponse defines model for SIWESessionResponse.
type SIWESessionResponse struct {
	Address *string `json:"address,omitempty"`
	ChainId *int    `json:"chainId,omitempty"`
}

// SIWEVerifyBody defines model for SIWEVerifyBody.
type SIWEVerifyBody struct {
	Message   *string `json:"message"`
	Signature *string `json:"signature"`
}

// UsersGetNonceResult defines model for UsersGetNonceResult.
type UsersGetNonceResult struct {
	Nonce *string `json:"nonce"`
}

// WithdrawalHistoryResponse defines model for WithdrawalHistoryResponse.
type WithdrawalHistoryResponse struct {
	Count       *uint               `json:"count,omitempty"`
	List        *[]WithdrawalRecord `json:"list,omitempty"`
	PageCurrent *int64              `json:"page_current,omitempty"`
	PageMax     *int64              `json:"page_max,omitempty"`
}

// WithdrawalRecord defines model for WithdrawalRecord.
type WithdrawalRecord struct {
	Amount *float32 `json:"amount,omitempty"`

	// BlockTimestamp Date of the record's block timestamp, in milliseconds.
	BlockTimestamp *int64   `json:"block_timestamp,omitempty"`
	Fee            *float32 `json:"fee,omitempty"`
	Index          *int     `json:"index,omitempty"`
	TxHash         *string  `json:"tx_hash,omitempty"`

	// User Token been withdrew to which address
	User *string `json:"user,omitempty"`
}

// Amount defines model for amount.
type Amount = float32

// Limit defines model for limit.
type Limit = uint

// Merge defines model for merge.
type Merge = bool

// Page defines model for page.
type Page = int64

// Since defines model for since.
type Since = int64

// Until defines model for until.
type Until = int64

// HealthCheckParams defines parameters for HealthCheck.
type HealthCheckParams struct {
	Type *HealthCheckParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// HealthCheckParamsType defines parameters for HealthCheck.
type HealthCheckParamsType string

// GetCollectionHistoryParams defines parameters for GetCollectionHistory.
type GetCollectionHistoryParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetConsumptionHistoryByAccountParams defines parameters for GetConsumptionHistoryByAccount.
type GetConsumptionHistoryByAccountParams struct {
	// Since Since timestamp (milliseconds)
	Since *Since `form:"since,omitempty" json:"since,omitempty"`

	// Until Until timestamp (milliseconds)
	Until *Until `form:"until,omitempty" json:"until,omitempty"`

	// Merge Whether to merge collection stats
	Merge *Merge `form:"merge,omitempty" json:"merge,omitempty"`
}

// GetConsumptionHistoryByKeyParams defines parameters for GetConsumptionHistoryByKey.
type GetConsumptionHistoryByKeyParams struct {
	// Since Since timestamp (milliseconds)
	Since *Since `form:"since,omitempty" json:"since,omitempty"`

	// Until Until timestamp (milliseconds)
	Until *Until `form:"until,omitempty" json:"until,omitempty"`

	// Merge Whether to merge collection stats
	Merge *Merge `form:"merge,omitempty" json:"merge,omitempty"`
}

// GetDepositHistoryParams defines parameters for GetDepositHistory.
type GetDepositHistoryParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetWithdrawalHistoryParams defines parameters for GetWithdrawalHistory.
type GetWithdrawalHistoryParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// SetPendingRequestWithdrawParams defines parameters for SetPendingRequestWithdraw.
type SetPendingRequestWithdrawParams struct {
	// Amount Amount of tokens
	Amount Amount `form:"amount" json:"amount"`
}

// GenerateKeyJSONRequestBody defines body for GenerateKey for application/json ContentType.
type GenerateKeyJSONRequestBody = KeyInfoBody

// UpdateKeyInfoJSONRequestBody defines body for UpdateKeyInfo for application/json ContentType.
type UpdateKeyInfoJSONRequestBody = KeyInfoBody

// SIWEVerifyJSONRequestBody defines body for SIWEVerify for application/json ContentType.
type SIWEVerifyJSONRequestBody = SIWEVerifyBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HealthCheck request
	HealthCheck(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionHistory request
	GetCollectionHistory(ctx context.Context, params *GetCollectionHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsumptionHistoryByAccount request
	GetConsumptionHistoryByAccount(ctx context.Context, params *GetConsumptionHistoryByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsumptionHistoryByKey request
	GetConsumptionHistoryByKey(ctx context.Context, key int, params *GetConsumptionHistoryByKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDepositHistory request
	GetDepositHistory(ctx context.Context, params *GetDepositHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWithdrawalHistory request
	GetWithdrawalHistory(ctx context.Context, params *GetWithdrawalHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateKeyWithBody request with any body
	GenerateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateKey(ctx context.Context, body GenerateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKey request
	DeleteKey(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKey request
	GetKey(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RotateKey request
	RotateKey(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateKeyInfoWithBody request with any body
	UpdateKeyInfoWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateKeyInfo(ctx context.Context, id int, body UpdateKeyInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeys request
	GetKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingRequestWithdraw request
	GetPendingRequestWithdraw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPendingRequestWithdraw request
	SetPendingRequestWithdraw(ctx context.Context, params *SetPendingRequestWithdrawParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRUStatus request
	GetRUStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SIWELogout request
	SIWELogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SIWEGetNonce request
	SIWEGetNonce(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SIWEGetSession request
	SIWEGetSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SIWEVerifyWithBody request with any body
	SIWEVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SIWEVerify(ctx context.Context, body SIWEVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HealthCheck(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionHistory(ctx context.Context, params *GetCollectionHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsumptionHistoryByAccount(ctx context.Context, params *GetConsumptionHistoryByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsumptionHistoryByAccountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsumptionHistoryByKey(ctx context.Context, key int, params *GetConsumptionHistoryByKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsumptionHistoryByKeyRequest(c.Server, key, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDepositHistory(ctx context.Context, params *GetDepositHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepositHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWithdrawalHistory(ctx context.Context, params *GetWithdrawalHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWithdrawalHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateKey(ctx context.Context, body GenerateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKey(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKey(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RotateKey(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRotateKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeyInfoWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeyInfoRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateKeyInfo(ctx context.Context, id int, body UpdateKeyInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateKeyInfoRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingRequestWithdraw(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingRequestWithdrawRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPendingRequestWithdraw(ctx context.Context, params *SetPendingRequestWithdrawParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPendingRequestWithdrawRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRUStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRUStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWELogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWELogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWEGetNonce(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWEGetNonceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWEGetSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWEGetSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWEVerifyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWEVerifyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SIWEVerify(ctx context.Context, body SIWEVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSIWEVerifyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string, params *HealthCheckParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionHistoryRequest generates requests for GetCollectionHistory
func NewGetCollectionHistoryRequest(server string, params *GetCollectionHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/collection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsumptionHistoryByAccountRequest generates requests for GetConsumptionHistoryByAccount
func NewGetConsumptionHistoryByAccountRequest(server string, params *GetConsumptionHistoryByAccountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/consumption")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Merge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merge", runtime.ParamLocationQuery, *params.Merge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsumptionHistoryByKeyRequest generates requests for GetConsumptionHistoryByKey
func NewGetConsumptionHistoryByKeyRequest(server string, key int, params *GetConsumptionHistoryByKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/consumption/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Merge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "merge", runtime.ParamLocationQuery, *params.Merge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDepositHistoryRequest generates requests for GetDepositHistory
func NewGetDepositHistoryRequest(server string, params *GetDepositHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/deposit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWithdrawalHistoryRequest generates requests for GetWithdrawalHistory
func NewGetWithdrawalHistoryRequest(server string, params *GetWithdrawalHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/history/withdrawal")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateKeyRequest calls the generic GenerateKey builder with application/json body
func NewGenerateKeyRequest(server string, body GenerateKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateKeyRequestWithBody generates requests for GenerateKey with any type of body
func NewGenerateKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteKeyRequest generates requests for DeleteKey
func NewDeleteKeyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeyRequest generates requests for GetKey
func NewGetKeyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRotateKeyRequest generates requests for RotateKey
func NewRotateKeyRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateKeyInfoRequest calls the generic UpdateKeyInfo builder with application/json body
func NewUpdateKeyInfoRequest(server string, id int, body UpdateKeyInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateKeyInfoRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateKeyInfoRequestWithBody generates requests for UpdateKeyInfo with any type of body
func NewUpdateKeyInfoRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/key/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeysRequest generates requests for GetKeys
func NewGetKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingRequestWithdrawRequest generates requests for GetPendingRequestWithdraw
func NewGetPendingRequestWithdrawRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request/withdraw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPendingRequestWithdrawRequest generates requests for SetPendingRequestWithdraw
func NewSetPendingRequestWithdrawRequest(server string, params *SetPendingRequestWithdrawParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request/withdraw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRUStatusRequest generates requests for GetRUStatus
func NewGetRUStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ru/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSIWELogoutRequest generates requests for SIWELogout
func NewSIWELogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/siwe/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSIWEGetNonceRequest generates requests for SIWEGetNonce
func NewSIWEGetNonceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/siwe/nonce")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSIWEGetSessionRequest generates requests for SIWEGetSession
func NewSIWEGetSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/siwe/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSIWEVerifyRequest calls the generic SIWEVerify builder with application/json body
func NewSIWEVerifyRequest(server string, body SIWEVerifyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSIWEVerifyRequestWithBody(server, "application/json", bodyReader)
}

// NewSIWEVerifyRequestWithBody generates requests for SIWEVerify with any type of body
func NewSIWEVerifyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/siwe/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// GetCollectionHistoryWithResponse request
	GetCollectionHistoryWithResponse(ctx context.Context, params *GetCollectionHistoryParams, reqEditors ...RequestEditorFn) (*GetCollectionHistoryResponse, error)

	// GetConsumptionHistoryByAccountWithResponse request
	GetConsumptionHistoryByAccountWithResponse(ctx context.Context, params *GetConsumptionHistoryByAccountParams, reqEditors ...RequestEditorFn) (*GetConsumptionHistoryByAccountResponse, error)

	// GetConsumptionHistoryByKeyWithResponse request
	GetConsumptionHistoryByKeyWithResponse(ctx context.Context, key int, params *GetConsumptionHistoryByKeyParams, reqEditors ...RequestEditorFn) (*GetConsumptionHistoryByKeyResponse, error)

	// GetDepositHistoryWithResponse request
	GetDepositHistoryWithResponse(ctx context.Context, params *GetDepositHistoryParams, reqEditors ...RequestEditorFn) (*GetDepositHistoryResponse, error)

	// GetWithdrawalHistoryWithResponse request
	GetWithdrawalHistoryWithResponse(ctx context.Context, params *GetWithdrawalHistoryParams, reqEditors ...RequestEditorFn) (*GetWithdrawalHistoryResponse, error)

	// GenerateKeyWithBodyWithResponse request with any body
	GenerateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error)

	GenerateKeyWithResponse(ctx context.Context, body GenerateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error)

	// DeleteKeyWithResponse request
	DeleteKeyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error)

	// GetKeyWithResponse request
	GetKeyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetKeyResponse, error)

	// RotateKeyWithResponse request
	RotateKeyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RotateKeyResponse, error)

	// UpdateKeyInfoWithBodyWithResponse request with any body
	UpdateKeyInfoWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeyInfoResponse, error)

	UpdateKeyInfoWithResponse(ctx context.Context, id int, body UpdateKeyInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeyInfoResponse, error)

	// GetKeysWithResponse request
	GetKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeysResponse, error)

	// GetPendingRequestWithdrawWithResponse request
	GetPendingRequestWithdrawWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingRequestWithdrawResponse, error)

	// SetPendingRequestWithdrawWithResponse request
	SetPendingRequestWithdrawWithResponse(ctx context.Context, params *SetPendingRequestWithdrawParams, reqEditors ...RequestEditorFn) (*SetPendingRequestWithdrawResponse, error)

	// GetRUStatusWithResponse request
	GetRUStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRUStatusResponse, error)

	// SIWELogoutWithResponse request
	SIWELogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWELogoutResponse, error)

	// SIWEGetNonceWithResponse request
	SIWEGetNonceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWEGetNonceResponse, error)

	// SIWEGetSessionWithResponse request
	SIWEGetSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWEGetSessionResponse, error)

	// SIWEVerifyWithBodyWithResponse request with any body
	SIWEVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SIWEVerifyResponse, error)

	SIWEVerifyWithResponse(ctx context.Context, body SIWEVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*SIWEVerifyResponse, error)
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionHistoryResponse
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetCollectionHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsumptionHistoryByAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsumptionLogResponse
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetConsumptionHistoryByAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsumptionHistoryByAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsumptionHistoryByKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsumptionLogResponse
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetConsumptionHistoryByKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsumptionHistoryByKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDepositHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DepositHistoryResponse
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetDepositHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepositHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWithdrawalHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WithdrawalHistoryResponse
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetWithdrawalHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWithdrawalHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GenerateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r DeleteKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RotateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON401      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r RotateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RotateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateKeyInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON401      *BadRequestRes
	JSON404      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r UpdateKeyInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeyInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Keys
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingRequestWithdrawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRequestWithdrawResponse
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetPendingRequestWithdrawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingRequestWithdrawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPendingRequestWithdrawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r SetPendingRequestWithdrawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPendingRequestWithdrawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRUStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RUStatus
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r GetRUStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRUStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SIWELogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SIWELogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SIWELogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SIWEGetNonceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r SIWEGetNonceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SIWEGetNonceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SIWEGetSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SIWESessionResponse
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r SIWEGetSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SIWEGetSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SIWEVerifyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestRes
	JSON401      *BadRequestRes
	JSON500      *BadRequestRes
}

// Status returns HTTPResponse.Status
func (r SIWEVerifyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SIWEVerifyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, params *HealthCheckParams, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// GetCollectionHistoryWithResponse request returning *GetCollectionHistoryResponse
func (c *ClientWithResponses) GetCollectionHistoryWithResponse(ctx context.Context, params *GetCollectionHistoryParams, reqEditors ...RequestEditorFn) (*GetCollectionHistoryResponse, error) {
	rsp, err := c.GetCollectionHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionHistoryResponse(rsp)
}

// GetConsumptionHistoryByAccountWithResponse request returning *GetConsumptionHistoryByAccountResponse
func (c *ClientWithResponses) GetConsumptionHistoryByAccountWithResponse(ctx context.Context, params *GetConsumptionHistoryByAccountParams, reqEditors ...RequestEditorFn) (*GetConsumptionHistoryByAccountResponse, error) {
	rsp, err := c.GetConsumptionHistoryByAccount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsumptionHistoryByAccountResponse(rsp)
}

// GetConsumptionHistoryByKeyWithResponse request returning *GetConsumptionHistoryByKeyResponse
func (c *ClientWithResponses) GetConsumptionHistoryByKeyWithResponse(ctx context.Context, key int, params *GetConsumptionHistoryByKeyParams, reqEditors ...RequestEditorFn) (*GetConsumptionHistoryByKeyResponse, error) {
	rsp, err := c.GetConsumptionHistoryByKey(ctx, key, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsumptionHistoryByKeyResponse(rsp)
}

// GetDepositHistoryWithResponse request returning *GetDepositHistoryResponse
func (c *ClientWithResponses) GetDepositHistoryWithResponse(ctx context.Context, params *GetDepositHistoryParams, reqEditors ...RequestEditorFn) (*GetDepositHistoryResponse, error) {
	rsp, err := c.GetDepositHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepositHistoryResponse(rsp)
}

// GetWithdrawalHistoryWithResponse request returning *GetWithdrawalHistoryResponse
func (c *ClientWithResponses) GetWithdrawalHistoryWithResponse(ctx context.Context, params *GetWithdrawalHistoryParams, reqEditors ...RequestEditorFn) (*GetWithdrawalHistoryResponse, error) {
	rsp, err := c.GetWithdrawalHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWithdrawalHistoryResponse(rsp)
}

// GenerateKeyWithBodyWithResponse request with arbitrary body returning *GenerateKeyResponse
func (c *ClientWithResponses) GenerateKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error) {
	rsp, err := c.GenerateKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateKeyResponse(rsp)
}

func (c *ClientWithResponses) GenerateKeyWithResponse(ctx context.Context, body GenerateKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateKeyResponse, error) {
	rsp, err := c.GenerateKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateKeyResponse(rsp)
}

// DeleteKeyWithResponse request returning *DeleteKeyResponse
func (c *ClientWithResponses) DeleteKeyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*DeleteKeyResponse, error) {
	rsp, err := c.DeleteKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeyResponse(rsp)
}

// GetKeyWithResponse request returning *GetKeyResponse
func (c *ClientWithResponses) GetKeyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetKeyResponse, error) {
	rsp, err := c.GetKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeyResponse(rsp)
}

// RotateKeyWithResponse request returning *RotateKeyResponse
func (c *ClientWithResponses) RotateKeyWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RotateKeyResponse, error) {
	rsp, err := c.RotateKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRotateKeyResponse(rsp)
}

// UpdateKeyInfoWithBodyWithResponse request with arbitrary body returning *UpdateKeyInfoResponse
func (c *ClientWithResponses) UpdateKeyInfoWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateKeyInfoResponse, error) {
	rsp, err := c.UpdateKeyInfoWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeyInfoResponse(rsp)
}

func (c *ClientWithResponses) UpdateKeyInfoWithResponse(ctx context.Context, id int, body UpdateKeyInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateKeyInfoResponse, error) {
	rsp, err := c.UpdateKeyInfo(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateKeyInfoResponse(rsp)
}

// GetKeysWithResponse request returning *GetKeysResponse
func (c *ClientWithResponses) GetKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeysResponse, error) {
	rsp, err := c.GetKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeysResponse(rsp)
}

// GetPendingRequestWithdrawWithResponse request returning *GetPendingRequestWithdrawResponse
func (c *ClientWithResponses) GetPendingRequestWithdrawWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPendingRequestWithdrawResponse, error) {
	rsp, err := c.GetPendingRequestWithdraw(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingRequestWithdrawResponse(rsp)
}

// SetPendingRequestWithdrawWithResponse request returning *SetPendingRequestWithdrawResponse
func (c *ClientWithResponses) SetPendingRequestWithdrawWithResponse(ctx context.Context, params *SetPendingRequestWithdrawParams, reqEditors ...RequestEditorFn) (*SetPendingRequestWithdrawResponse, error) {
	rsp, err := c.SetPendingRequestWithdraw(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPendingRequestWithdrawResponse(rsp)
}

// GetRUStatusWithResponse request returning *GetRUStatusResponse
func (c *ClientWithResponses) GetRUStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRUStatusResponse, error) {
	rsp, err := c.GetRUStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRUStatusResponse(rsp)
}

// SIWELogoutWithResponse request returning *SIWELogoutResponse
func (c *ClientWithResponses) SIWELogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWELogoutResponse, error) {
	rsp, err := c.SIWELogout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWELogoutResponse(rsp)
}

// SIWEGetNonceWithResponse request returning *SIWEGetNonceResponse
func (c *ClientWithResponses) SIWEGetNonceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWEGetNonceResponse, error) {
	rsp, err := c.SIWEGetNonce(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWEGetNonceResponse(rsp)
}

// SIWEGetSessionWithResponse request returning *SIWEGetSessionResponse
func (c *ClientWithResponses) SIWEGetSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SIWEGetSessionResponse, error) {
	rsp, err := c.SIWEGetSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWEGetSessionResponse(rsp)
}

// SIWEVerifyWithBodyWithResponse request with arbitrary body returning *SIWEVerifyResponse
func (c *ClientWithResponses) SIWEVerifyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SIWEVerifyResponse, error) {
	rsp, err := c.SIWEVerifyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWEVerifyResponse(rsp)
}

func (c *ClientWithResponses) SIWEVerifyWithResponse(ctx context.Context, body SIWEVerifyJSONRequestBody, reqEditors ...RequestEditorFn) (*SIWEVerifyResponse, error) {
	rsp, err := c.SIWEVerify(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSIWEVerifyResponse(rsp)
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCollectionHistoryResponse parses an HTTP response from a GetCollectionHistoryWithResponse call
func ParseGetCollectionHistoryResponse(rsp *http.Response) (*GetCollectionHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionHistoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConsumptionHistoryByAccountResponse parses an HTTP response from a GetConsumptionHistoryByAccountWithResponse call
func ParseGetConsumptionHistoryByAccountResponse(rsp *http.Response) (*GetConsumptionHistoryByAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsumptionHistoryByAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsumptionLogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetConsumptionHistoryByKeyResponse parses an HTTP response from a GetConsumptionHistoryByKeyWithResponse call
func ParseGetConsumptionHistoryByKeyResponse(rsp *http.Response) (*GetConsumptionHistoryByKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsumptionHistoryByKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsumptionLogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetDepositHistoryResponse parses an HTTP response from a GetDepositHistoryWithResponse call
func ParseGetDepositHistoryResponse(rsp *http.Response) (*GetDepositHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDepositHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DepositHistoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWithdrawalHistoryResponse parses an HTTP response from a GetWithdrawalHistoryWithResponse call
func ParseGetWithdrawalHistoryResponse(rsp *http.Response) (*GetWithdrawalHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWithdrawalHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WithdrawalHistoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateKeyResponse parses an HTTP response from a GenerateKeyWithResponse call
func ParseGenerateKeyResponse(rsp *http.Response) (*GenerateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteKeyResponse parses an HTTP response from a DeleteKeyWithResponse call
func ParseDeleteKeyResponse(rsp *http.Response) (*DeleteKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetKeyResponse parses an HTTP response from a GetKeyWithResponse call
func ParseGetKeyResponse(rsp *http.Response) (*GetKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRotateKeyResponse parses an HTTP response from a RotateKeyWithResponse call
func ParseRotateKeyResponse(rsp *http.Response) (*RotateKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RotateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateKeyInfoResponse parses an HTTP response from a UpdateKeyInfoWithResponse call
func ParseUpdateKeyInfoResponse(rsp *http.Response) (*UpdateKeyInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateKeyInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetKeysResponse parses an HTTP response from a GetKeysWithResponse call
func ParseGetKeysResponse(rsp *http.Response) (*GetKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Keys
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPendingRequestWithdrawResponse parses an HTTP response from a GetPendingRequestWithdrawWithResponse call
func ParseGetPendingRequestWithdrawResponse(rsp *http.Response) (*GetPendingRequestWithdrawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingRequestWithdrawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRequestWithdrawResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetPendingRequestWithdrawResponse parses an HTTP response from a SetPendingRequestWithdrawWithResponse call
func ParseSetPendingRequestWithdrawResponse(rsp *http.Response) (*SetPendingRequestWithdrawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPendingRequestWithdrawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRUStatusResponse parses an HTTP response from a GetRUStatusWithResponse call
func ParseGetRUStatusResponse(rsp *http.Response) (*GetRUStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRUStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RUStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseSIWELogoutResponse parses an HTTP response from a SIWELogoutWithResponse call
func ParseSIWELogoutResponse(rsp *http.Response) (*SIWELogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SIWELogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSIWEGetNonceResponse parses an HTTP response from a SIWEGetNonceWithResponse call
func ParseSIWEGetNonceResponse(rsp *http.Response) (*SIWEGetNonceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SIWEGetNonceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSIWEGetSessionResponse parses an HTTP response from a SIWEGetSessionWithResponse call
func ParseSIWEGetSessionResponse(rsp *http.Response) (*SIWEGetSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SIWEGetSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SIWESessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSIWEVerifyResponse parses an HTTP response from a SIWEVerifyWithResponse call
func ParseSIWEVerifyResponse(rsp *http.Response) (*SIWEVerifyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SIWEVerifyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BadRequestRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// health check
	// (GET /health)
	HealthCheck(ctx echo.Context, params HealthCheckParams) error
	// Get collection history
	// (GET /history/collection)
	GetCollectionHistory(ctx echo.Context, params GetCollectionHistoryParams) error
	// Get consumption history of a specific account
	// (GET /history/consumption)
	GetConsumptionHistoryByAccount(ctx echo.Context, params GetConsumptionHistoryByAccountParams) error
	// Get consumption history of a specific key
	// (GET /history/consumption/{key})
	GetConsumptionHistoryByKey(ctx echo.Context, key int, params GetConsumptionHistoryByKeyParams) error
	// Get deposit history
	// (GET /history/deposit)
	GetDepositHistory(ctx echo.Context, params GetDepositHistoryParams) error
	// Get withdrawal history
	// (GET /history/withdrawal)
	GetWithdrawalHistory(ctx echo.Context, params GetWithdrawalHistoryParams) error
	// Generate an API Key
	// (POST /key)
	GenerateKey(ctx echo.Context) error
	// Delete an API Key
	// (DELETE /key/{id})
	DeleteKey(ctx echo.Context, id int) error
	// Get an API Key' info
	// (GET /key/{id})
	GetKey(ctx echo.Context, id int) error
	// Reassign the API Key's secret
	// (PATCH /key/{id})
	RotateKey(ctx echo.Context, id int) error
	// Update an API Key's info
	// (PUT /key/{id})
	UpdateKeyInfo(ctx echo.Context, id int) error
	// List API Keys of current account
	// (GET /keys)
	GetKeys(ctx echo.Context) error
	// Get current withdraw request
	// (GET /request/withdraw)
	GetPendingRequestWithdraw(ctx echo.Context) error
	// Request withdraw tokens at the end of this epoch
	// (POST /request/withdraw)
	SetPendingRequestWithdraw(ctx echo.Context, params SetPendingRequestWithdrawParams) error
	// Get account usage
	// (GET /ru/status)
	GetRUStatus(ctx echo.Context) error
	// SIWE logout
	// (GET /users/siwe/logout)
	SIWELogout(ctx echo.Context) error
	// Get SIWE nonce
	// (GET /users/siwe/nonce)
	SIWEGetNonce(ctx echo.Context) error
	// Get SIWE session
	// (GET /users/siwe/session)
	SIWEGetSession(ctx echo.Context) error
	// Verify SIWE (login)
	// (POST /users/siwe/verify)
	SIWEVerify(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params HealthCheckParams
	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx, params)
	return err
}

// GetCollectionHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetCollectionHistory(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectionHistoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCollectionHistory(ctx, params)
	return err
}

// GetConsumptionHistoryByAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetConsumptionHistoryByAccount(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsumptionHistoryByAccountParams
	// ------------- Optional query parameter "since" -------------

	err = runtime.BindQueryParameter("form", true, false, "since", ctx.QueryParams(), &params.Since)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since: %s", err))
	}

	// ------------- Optional query parameter "until" -------------

	err = runtime.BindQueryParameter("form", true, false, "until", ctx.QueryParams(), &params.Until)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until: %s", err))
	}

	// ------------- Optional query parameter "merge" -------------

	err = runtime.BindQueryParameter("form", true, false, "merge", ctx.QueryParams(), &params.Merge)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter merge: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConsumptionHistoryByAccount(ctx, params)
	return err
}

// GetConsumptionHistoryByKey converts echo context to params.
func (w *ServerInterfaceWrapper) GetConsumptionHistoryByKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "key" -------------
	var key int

	err = runtime.BindStyledParameterWithOptions("simple", "key", ctx.Param("key"), &key, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsumptionHistoryByKeyParams
	// ------------- Optional query parameter "since" -------------

	err = runtime.BindQueryParameter("form", true, false, "since", ctx.QueryParams(), &params.Since)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since: %s", err))
	}

	// ------------- Optional query parameter "until" -------------

	err = runtime.BindQueryParameter("form", true, false, "until", ctx.QueryParams(), &params.Until)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until: %s", err))
	}

	// ------------- Optional query parameter "merge" -------------

	err = runtime.BindQueryParameter("form", true, false, "merge", ctx.QueryParams(), &params.Merge)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter merge: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConsumptionHistoryByKey(ctx, key, params)
	return err
}

// GetDepositHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetDepositHistory(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDepositHistoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDepositHistory(ctx, params)
	return err
}

// GetWithdrawalHistory converts echo context to params.
func (w *ServerInterfaceWrapper) GetWithdrawalHistory(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWithdrawalHistoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWithdrawalHistory(ctx, params)
	return err
}

// GenerateKey converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateKey(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GenerateKey(ctx)
	return err
}

// DeleteKey converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteKey(ctx, id)
	return err
}

// GetKey converts echo context to params.
func (w *ServerInterfaceWrapper) GetKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetKey(ctx, id)
	return err
}

// RotateKey converts echo context to params.
func (w *ServerInterfaceWrapper) RotateKey(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RotateKey(ctx, id)
	return err
}

// UpdateKeyInfo converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateKeyInfo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateKeyInfo(ctx, id)
	return err
}

// GetKeys converts echo context to params.
func (w *ServerInterfaceWrapper) GetKeys(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetKeys(ctx)
	return err
}

// GetPendingRequestWithdraw converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingRequestWithdraw(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPendingRequestWithdraw(ctx)
	return err
}

// SetPendingRequestWithdraw converts echo context to params.
func (w *ServerInterfaceWrapper) SetPendingRequestWithdraw(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetPendingRequestWithdrawParams
	// ------------- Required query parameter "amount" -------------

	err = runtime.BindQueryParameter("form", true, true, "amount", ctx.QueryParams(), &params.Amount)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter amount: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetPendingRequestWithdraw(ctx, params)
	return err
}

// GetRUStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetRUStatus(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRUStatus(ctx)
	return err
}

// SIWELogout converts echo context to params.
func (w *ServerInterfaceWrapper) SIWELogout(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SIWELogout(ctx)
	return err
}

// SIWEGetNonce converts echo context to params.
func (w *ServerInterfaceWrapper) SIWEGetNonce(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SIWEGetNonce(ctx)
	return err
}

// SIWEGetSession converts echo context to params.
func (w *ServerInterfaceWrapper) SIWEGetSession(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SIWEGetSession(ctx)
	return err
}

// SIWEVerify converts echo context to params.
func (w *ServerInterfaceWrapper) SIWEVerify(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SIWEVerify(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/health", wrapper.HealthCheck)
	router.GET(baseURL+"/history/collection", wrapper.GetCollectionHistory)
	router.GET(baseURL+"/history/consumption", wrapper.GetConsumptionHistoryByAccount)
	router.GET(baseURL+"/history/consumption/:key", wrapper.GetConsumptionHistoryByKey)
	router.GET(baseURL+"/history/deposit", wrapper.GetDepositHistory)
	router.GET(baseURL+"/history/withdrawal", wrapper.GetWithdrawalHistory)
	router.POST(baseURL+"/key", wrapper.GenerateKey)
	router.DELETE(baseURL+"/key/:id", wrapper.DeleteKey)
	router.GET(baseURL+"/key/:id", wrapper.GetKey)
	router.PATCH(baseURL+"/key/:id", wrapper.RotateKey)
	router.PUT(baseURL+"/key/:id", wrapper.UpdateKeyInfo)
	router.GET(baseURL+"/keys", wrapper.GetKeys)
	router.GET(baseURL+"/request/withdraw", wrapper.GetPendingRequestWithdraw)
	router.POST(baseURL+"/request/withdraw", wrapper.SetPendingRequestWithdraw)
	router.GET(baseURL+"/ru/status", wrapper.GetRUStatus)
	router.GET(baseURL+"/users/siwe/logout", wrapper.SIWELogout)
	router.GET(baseURL+"/users/siwe/nonce", wrapper.SIWEGetNonce)
	router.GET(baseURL+"/users/siwe/session", wrapper.SIWEGetSession)
	router.POST(baseURL+"/users/siwe/verify", wrapper.SIWEVerify)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xbfXPauPN/Kxr9fjN3N0ODgRAInfsjT5cjbdMrSZrr02SEvcYqtuRKcgnt8N6/I8lg",
	"iG0gTZO0V2Y602DJ0mr3sx+tVuuv2OVRzBkwJXHnK46JIBEoEOYXiXjClP7LA+kKGivKGe7gPfMccR8p",
	"PgQmcQVT/fxTAmKMK5iRCHBn+noFC/iUUAEe7iiRQAVLN4CI6HF9LiKicAf7ISe6qxrH+lWWRH0QeDKp",
	"4JBGtECG5/oxUgEg21dLQxVEEsUgUEwGUCKVHW9eCA98koQKd2qOU8lESiibk4gyBYNUpAjEAPIiXQag",
	"AhBIcWR6IJeHIbi6FUlFVJme7HCFEvkklDCToc95CIQZGcwKcyKcB2DWniqlZMJUOwVmoEztbBcvWlLm",
	"Fsx4ph8jRSOQikQx+j2iYUgluJx58o8SAexYt5UgYYqGeQku9OPbSmDHup0Ek2l34xz7xOvBpwSk6oH1",
	"HcFjEIraX5Ec6P/SQaQSlA1wBV8/4ZGGaazGqXX1sGkv3v8IrsKTCj6YIedvKhUX4x7ImDMJ+YncqY+u",
	"Aq52JWl6Gj/Rf/y/AB938P9VMxaopkusZiL0wOXCw5mcRAgyxikIr9xECLghQpkO01cicr2u0ZeoJpUr",
	"p5GMtm6wSQX3Q+4Or2ZYyYPpkCgwxBYAEmb83yQyb2UIqyDK0DzItnBlnaVT5sH1nFhzTer6KiAyyCOm",
	"RAVMJpER+Tkf7I+fwbhACzG9ckkYygKW4IqEc7y5908Xma4oIh6stxg3k+HKIwrKVTkKqBsYhc69g6jU",
	"U7pJSBR4yOdia86Fv02/QxhfWfe+KcozGKNT3VK5qd4KFslVIsEr01LvApnmyreidd5U5V4cWDe/hXfm",
	"IVDgoCWkvdw0MQjKPb1lCSXvbpYS2l5LBtDT3FGCIrMcQswlVY9Grun8PxazLgr169HqMah0R7+kKvAE",
	"GZUDI1PGGiFsbqblhD1v9xuB94yoDTCRl+jVIBVQiQRPmLeexrKZlOa41fNIG+TpaYYw/k0iVwAxfdez",
	"kFdsnqFVQ46SpyRextXlCkrZ+lsVMx2/RC3T0e+kjhI8dJnP97lXgIsSbZSMI9fmoJIto3dxpohK5K8E",
	"UJFclRwzD+xKdRgwPTjeAkf/NZyedS+PzkBKE3yXUqPnCZBy5elHiQR0IBkQyrpFDFHUPydV4ZHKSvoa",
	"BPXHxU4VgZTpCRquSRSHJjXAXRIGXKpOw3EcNCJMSTTmiT7RSzpgeoMaURXoZwId6cM+JBEirgFh5z1z",
	"rg8bR20XttvbNfB2mu0jt+25/d3d/RZpbffhr4NGq1VvNo723rMzPWCXIb3XZGMpjmLBP4OZ1uVMCR5a",
	"C45IGILaes8uet0OCpSKO9XqosTv2WsQ2jgdVHvPDrRiUffQ/DjlzIUO+nLQPn7ZOjyuB6+f9z7B/nvW",
	"lTIBD+2pDqo79caTmvOkVjt3Wp16vdPY2XKc7be5qLlE51pFRCXihlad62bD2XWddq21s91v9L3Gbr1O",
	"/JZfc9uOUyc7fd+HVos0AAi0odny2tukse070Go0m/1ms+bs1L3mTrvlQ9Nr1Vo7rd06cR3wao7XdpqN",
	"7VqftD2/WW80XbdRa7Q84ja8fh9Ird5qt8Cv9ddbwrrgupAg5DEoo9QeSJOqydE2T0Pvb0wBTGMQEj5a",
	"lJqJ8GMFqjm5fppY1QcoFOqbYtgKTiSIooPrEBjqA1i28gSMNK/Yg9aUnSur4wnt0uAmgqrxmUaEVe3J",
	"5fleoow8JrHmcj6kMJf1TVRwZfLC2RwkpibamJil+twshqowbXsyIApGZIwr+LMlMNzBtS1ny9GL5DEw",
	"ElPcwY0tZ6uGNYBUYGSpBkBCK8sAjLk1CMwWp3cU/LdpPgjAHZrXsuT2u6+FaUEj73xWEFgS4c47HNLP",
	"wKzeBBCPmr8/5JX4QbdbPzUS1h2nIGeauK5+f1LB27ZdM33qQCSOQ+qaNVQ/St3/65w8y9x1MSNplL04",
	"7z7xUNrDzr39cHMnbMj4iCFXGwMZtRmAJVFExBh3sDWlbdfIIQNtpvQx/qA7V9MsSTVLrJea/hhULoma",
	"x0DRkrIuVZMon1RW9rOhYZnxv4uCyzPCBcpeAFjt4Yx8wbT3c0G/gNksmg+J7i5TIBgJz0B8BnEkBBcL",
	"HGYMPmOvdx+0uTL4HYOav68JZoiZATF9chOJs5zVcijOuqXm2x/v2bDx1qC0Ob01UGkTb2t0tBdQ9wzf",
	"wjzoKuw+Jjk+mt/cErNZ0jQFpQ5eCJIxuNSn7vR4UgDlhSx+ObCrX4cwntwW3nrDz0F7cdlD08Xsw3pL",
	"z7Zh21B+bZwPEjdes/Ga7+o1FoJ5j7HPy/3Gs0n0Zd6yePnwMwclJdcom4jke0UkKZrWDkdGs5PxMgDm",
	"Ugs/MwbL8yQbGH4vGGawWonE9E4n5rIQe0z/hGez/R2kmiZov4sy5m9SjCoWg4jJPQJxluHY7MzfvDNb",
	"eCDCTE3Ks4U9WCNrhrHqV+pNbGYlBFt9sgi1Q/N8jSD0GYxR97A4DqXe7cLQ22d/HpGDHjT9s4DGtQFh",
	"jbgMDpXSTe7HMP2GWf5DID7lCvnmlvZ222eG39+QSX/nURwT5QZ5HPe4Ij8Kiz0YlDecuAxQPSDSXEar",
	"AGawkkiCK0AVISsp4MeL2LO46lo4Piy2frmwb4PoZYi2YJxnSVlMk2nsJ5edbU0J1P2aW2424zuF+c+p",
	"VFNTS8R9lJYPFGSqM7unrDHLcCzDwD/APMoGN4o57xMVS0pHN1mIu2drU3xMbY9SMMwBJXsyA4jZ/ArT",
	"EGdLIHK7PFhaZ/KTXftvILciwjKDZnCzXzkiYr83BObZ8iAqEcTcDVbB0NBXUpWzstoy3pqV3t4jU83m",
	"2OxhdwhZzKnO7lYokfZzyhkGktTmibQXjyOohnzAk/lLoRuK714eobRP5SZZdS+Pnk+b1ieZCg6AeOmH",
	"vGegnhzYOq18hXMIRKBZFddc6dOsgjMr6frzKfqHqODP6lP0t1LxSxaOnyK4jqkA+ed5kFTQCWHIqaHa",
	"bstBjtMx/9DF+cHTgoqzyfoKX9TQVNVGw3ltz0ovC5WtbWeGs92K9D2t7VztiAquVTUOCb2BycUppzPN",
	"qbTveuAPAvpxGEaMx0XaWeKej3J/gOwFApq7QVhwiAWlrjCRtFXkq4007VhiprNZ870xZlHR+89qnUyb",
	"K+zz2dTOz9/kLM5qa+vtoL+HfEDZH4Umsv3u6bLnRpH/+gf/O1LmXkqXpkCfUGY/4QB0cnluYwXkc4E0",
	"awJT6dJWUyuMT4L+sUtf0pPuxZdu7ZR2ZZf1mu5Bd6c7jP99fXCyuwXjky/eZZe+pN3rFx9fOKfnbxov",
	"D4ejLh3RfvSXenvW3emGvdBtvKLPD07iN/++oi8/HtVenL8Zv/gyHL34eLK71X4W/1Wrv/J3d98Oj7+8",
	"euO4p58dJsPgLX395nz3cH/vcPs8PB21xnt5vi/k8V8oYDCAS8dGPqHhI97oLvP5Yg/Nub3ZgfUg9ryT",
	"iBB3cBVPPkz+FwAA///MAvVkHEQAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
